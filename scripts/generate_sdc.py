
import json
import argparse
import os
import sys

def generate_sdc(design_name, period_ns=40.0, post_route=False):
    # Paths
    json_path = os.path.join("inputs", "designs", f"{design_name}_mapped.json")
    output_dir = os.path.join("build", design_name)
    sdc_path = os.path.join(output_dir, f"{design_name}.sdc")

    print(f"Generating SDC for design: {design_name}")
    print(f"Period: {period_ns} ns")
    print(f"Input JSON: {json_path}")
    print(f"Output SDC: {sdc_path}")

    if not os.path.exists(json_path):
        print(f"Error: JSON input file not found: {json_path}")
        sys.exit(1)

    # Ensure output directory exists
    os.makedirs(output_dir, exist_ok=True)

    try:
        with open(json_path, 'r') as f:
            data = json.load(f)
    except json.JSONDecodeError as e:
        print(f"Error decoding JSON: {e}")
        sys.exit(1)

    # Find top module
    modules = data.get("modules", {})
    if "sasic_top" in modules:
        top_module = modules["sasic_top"]
    elif design_name in modules:
        top_module = modules[design_name]
    else:
        found = False
        for mod_name, mod_data in modules.items():
            attrs = mod_data.get("attributes", {})
            if attrs.get("top", 0) == 1 or attrs.get("top") == "00000000000000000000000000000001":
                top_module = mod_data
                found = True
                break
        
        if not found:
            print("Error: Could not determine top module.")
            sys.exit(1)

    ports = top_module.get("ports", {})
    
    input_ports = []
    output_ports = []
    clock_port = "clk" # Default name
    reset_port = None

    for port_name, port_data in ports.items():
        direction = port_data.get("direction", "input")
        if direction == "input":
            if port_name == "clk":
                clock_port = port_name
            elif port_name == "rst_n":
                reset_port = port_name
            else:
                input_ports.append(port_name)
        elif direction == "output":
            output_ports.append(port_name)

    # Note: If clock port is not found in ports dictionary, we might have an issue.
    if clock_port not in ports:
        print(f"Warning: Clock port '{clock_port}' not found in ports list. Assuming it exists or check design.")

    # Calculate delays (20% of period)
    delay_val = period_ns * 0.2
    
    # Calculate frequency for comment
    freq_mhz = 1000.0 / period_ns

    with open(sdc_path, 'w') as f:
        f.write(f"# SDC File for {design_name}\n")
        f.write(f"# Generated by scripts/generate_sdc.py\n")
        f.write(f"# Clock Period: {period_ns} ns ({freq_mhz:.2f} MHz)\n\n")
        
        # OpenROAD/OpenSTA doesn't need current_design or set_units
        # Units are handled automatically based on library units
        
        # 1. Create Clock
        f.write(f"# Define primary clock\n")
        f.write(f"create_clock -name {clock_port} -period {period_ns} [get_ports {clock_port}]\n")
        f.write(f"set_clock_uncertainty 0.25 [get_clocks {clock_port}]\n")
        # set_propagated_clock should only be used post-route (after routing)
        # For pre-route STA, clock is ideal. For post-route STA, use propagated clock.
        if post_route:
            f.write(f"# Use propagated clock for post-route STA (uses actual clock tree delays)\n")
            f.write(f"set_propagated_clock [get_clocks {clock_port}]\n")
        f.write("\n")
        
        # 2. Input Delays (20% of period)
        if input_ports:
            f.write(f"# Input delays (20% of period = {delay_val} ns)\n")
            inputs_str = " ".join(input_ports)
            f.write(f"set_input_delay -clock {clock_port} {delay_val} [get_ports {{ {inputs_str} }}]\n")
            f.write("\n")
        
        # 3. Output Delays (20% of period)
        if output_ports:
            f.write(f"# Output delays (20% of period = {delay_val} ns)\n")
            outputs_str = " ".join(output_ports)
            f.write(f"set_output_delay -clock {clock_port} {delay_val} [get_ports {{ {outputs_str} }}]\n")
            # Set load for outputs (5fF = 0.005 pF)
            f.write(f"set_load 0.005 [get_ports {{ {outputs_str} }}]\n")
            f.write("\n")
        
        # 4. Design Rule Constraints (optional but recommended)
        if input_ports:
            f.write(f"# Design rule constraints\n")
            inputs_str = " ".join(input_ports)
            f.write(f"set_max_fanout 10.0 [get_ports {{ {inputs_str} }}]\n")
            f.write(f"set_max_transition 1.2 [get_ports {{ {inputs_str} }}]\n")
        else:
            f.write(f"# Design rule constraints\n")
            f.write(f"set_max_fanout 10.0 [all_inputs]\n")
            f.write(f"set_max_transition 1.2 [all_inputs]\n")
        
        # 5. False paths (optional)
        if reset_port:
            f.write("\n")
            f.write(f"# False path for asynchronous reset\n")
            f.write(f"set_false_path -from [get_ports {reset_port}]\n")

    print("SDC generation complete.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate SDC file from Yosys JSON netlist")
    parser.add_argument("design_name", help="Name of the design (e.g., 6502)")
    parser.add_argument("--period", type=float, default=40.0, help="Clock period in ns (default: 40.0)")
    parser.add_argument("--post-route", action="store_true", help="Generate post-route SDC with set_propagated_clock")
    
    args = parser.parse_args()
    
    generate_sdc(args.design_name, args.period, post_route=args.post_route)
